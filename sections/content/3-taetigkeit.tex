\section{Tätigkeit}

\subsection{Erstellen des Netzproviders}

%TODO: #edit Ubuntu und PPPoE klingen eher wie eine Anleitung, als wie eine "Dokumentation"
	\subsubsection{Ubuntu}
	Wie in \Verweis{subsec:ubuntu} beschrieben wird Version 14.04 LTS
	der Linuxdistribution Ubuntu installiert. Das bei der Herstellerwebsite\footnote{\url{http://releases.ubuntu.com/14.04/}},
	für Serverbetrieb erhältliche Image wird in einer virtuellen Maschine installiert.
	Diese weist folgende Eigenschaften auf:

	\begin{tabularx}{\textwidth}{|l|X|}
    	\hline
      		\textbf{Gerät} & \textbf{Typ} \\
    	\hline
    	\hline
    		CPU & 1x 64 Bit \\
    	\hline
    	\hline
    		RAM & 1x 1024 MB \\
    	\hline
    	\hline
    		HDD & 1x 10 GB \\
    	\hline
    	\hline
    		NIC & 2x Bridged (1x auf enp0s25; 1x auf wlp3s0) \\
    	\hline
    	\end{tabularx}

    	Aufgrund der Tatsache dass nur ein einziger Client über den Zugang von \textit{PPPoE}
    	zu erwarten ist, sind die Anforderungen an CPU, Arbeits- und Festplattenspeicher
    	recht gering. Wichtig ist das Vorhandensein zweier Netzwerkschnittstellen, die
    	auf jeweils eine physikalisch Schnittstelle geleitet werden. Dies ist notwendig,
    	da sowohl die \ac{MS} über eine Ethernetverbindung mit der virtuellen Maschine angebunden sein wird,
    	als auch eine Dauerhafte Internetverbindung mit der verbleibenden Schnittstelle
    	aufrecht erhalten werden muss. So ist es möglich nach erfolgreicher Authentisierung
    	des \ac{MS} den Zugang zum Internet freizuschalten.

    	\subsubsection{PPPoE}
    	kann nach der vollständigen Ubuntuinstallation durchgeführt werden. Hierzu wird die aktuelle
    	Version 3.11 auf der Herstellerwebsite\footnote{\url{https://www.roaringpenguin.com/products/pppoe}}
    	heruntergeladen und auf dem Server entpackt. Zusätzlich wird das Ubuntu-Paket zur Unterstützung
    	des Point-To-Point-Protocol (als \textit{ppp} erhältlich) benötigt. Sind diese beiden Grundvoraussetzungen
    	abgedeckt wird der Roaring Penguin PPPoE-Server ohne spezielle Änderungen kompiliert.

    	In der Datei \textit{/etc/ppp/pppoe-server-options} werden die Parameter gesetzt. Anzugeben
    	sind die DNS-Server sowie die CHAP-Authentifizierung. Der User für die Authentifizierung
    	wird unter \textit{/etc/ppp/chap-secrets} definiert.

    	Der zu verwendende Adresspool an IP-Adressen ist unter \textit{/etc/ppp/allip} anzugeben.

    	Abschließend fehlt noch die Deklaration der zu verwendenden Netzwerkschnittstelle (unter \textit{/etc/network/interfaces}),
    	die zum Betrieb mit PPPoE eingesetzt werden soll. Ihr muss eine valide IP-Adresse aus dem definierten
    	Pool sowie eine Subnetzmaske zugewiesen werden.

    	Alle Konfigurationsdateien befinden sich im Anhang. %TODO: #edit Anhang pflegen

    	Damit die Internetverbindung nach erfolgreicher Authentifizierung des \ac{MS} auch
    	korrekt von Provider freigeschaltet und weitergeleitet wird, muss eine IPTables-Regel
    	eingerichtet werden:

    	\begin{lstlisting}[language=bash]
		$ iptables -t nat -A POSTROUTING -s 192.168.178.0/24 -o enp0s25 -j MASQUERADE
	\end{lstlisting}

	Sie nimmt den Verkehr auf dem Device \textit{enp0s25} an und maskiert (vgl. \ac{NAT}) diesen
	für den weiteren Betrieb (wie es bei einem realen Provider auch wäre). Dies geschieht
	für eingehenden sowie ausgehenden Verkehr. Die auf den zweiten Netzwerkadapter geleitete
	Netzwerkschnittstelle bleibt mit Defaultwerten konfiguriert und fungiert als Zugangspunkt
	zum Internet.

	Nun kann der Server auf der gewünschten Netzwerkschnittstelle mit einer eigenen IP-Adresse
	gestartet und genutzt werden:
	\begin{lstlisting}[language=bash]
		pppoe-server -C isp -L 192.168.178.254 -p /etc/ppp/allip -I enp0s25
	\end{lstlisting}

        Korrekt konfigurierte Clients, die über die Zugangsdaten verfühen können sich über
        diese Verbindung anmelden und Internetzugriff erhalten.

%TODO: #remove
\clearpage

	\subsubsection{Implementierung AES}
	Die Blockchiffre AES wurde in der Datei \emph{rijndael.c} geschrieben. Der Code wurde in drei
	logische Teile unterteilt, nämlich die Variablen\-deklaration, die Main-Funktion, die die
	einzelen Runden steuert und Funktionen, die die konkrete Implementierung der jeweiligen
	Transformation bereitstellen. Desweiteren wurde ein eigener Variablentyp \emph{u8} definiert,
	der einfach eine verkürzte Form des unsigned integer ist.

		\paragraph{Variablen}
		
 
		\paragraph{'Unter'-Algorithmen}

	\subsubsection{Implementierung Milenage}

	\subsection{Erstellen des UE}
		\subsubsection{Aufsetzen des Raspberry Pis}
        \label{subsubsec:installpi}
			\paragraph{Raspbian} wird über die von der Webpräsenz\footnote{\url{https://www.raspberrypi.org/downloads/raspbian/}}
            des Projekts gehosteten vorgefertigten Builds aufgesetzt.

            Die SD-Karte muss nicht weiter formatiert und für die Installation vorbereitet werden. Das
            bereitstehende ISO-Image ist ein Abbild eines bereits korrekt formatierten sowie installierten
            Raspbian (Jessie). Nach kopieren (blockweise) des Images auf die SD-Karte kann von dieser direkt
            gebootet werden.

            Nach dem initialen Bootvorgang können Userspezifische Änderungen durchgeführt werden. Hierzu
            gehört das anpassen von Netzwerk- und Hostinformationen. Um später eine Administation via
            \ac{ssh}-Remotezugang zu ermöglichen wird auch dieser in der entsprechenden Konfigurationsdatei
            zum automatischen starten aktiviert.

            Für den weiteren Betrieb müssen Pakete aus dem offiziellen Resporitory
            nachinstalliert werden. Spezielle Pakete, die dort nicht verfügbar sind werden
            manuell kompiliert.

            \paragraph{SIM-Kartenleser} Der benötigte (herstellerspezifische)
            Cherry-Treiber ist nicht im offiziellen Repository enthalten, kann jedoch
            manuell kompiliert werden. Auf der Webpräsenz des Herstellers\footnote{\url{http://www.cherry.de/cid/download.php}}
            wird ein Treiber für den Betrieb mit 64-Bit Linuxdistributionen zu Verfügung gestellt.
            Selbiger kann nach Installation der nativen \textit{pcsc}-Pakete (aus dem Repository)
            kompiliert und eingesetzt werden.

            Sind diese Softwarepakete eingerichtet kann die SIM-Karte eingesetzt
            und erste Kommunikationsversuche durchgeführt werden. Hier bietet sich der vom
            Treiber mitgelieferte Scanmechanismus für neue Devices an. Da der Treiber
            Hotplugfähig ist kann direkt mit der SIM-Karte gearbeitet werden, sobald diese
            eingesetzt wird.

			\paragraph{pysim} kann von Kevin Prince's Githubrepository\footnote{\url{https://github.com/kevinprince/pysim}} bezogen werden. Es benötigt ebenso
            wie andere nachfolgend genannte Python-Skripte noch das Paket \textit{pysim}, welches
            in den offiziellen Raspbian Paketquellen zur Verfügung steht. Nach erfolgreicher Installation
            von Pysim und pullen des Skriptes wird selbiges über Python verwendet.

            \paragraph{osmo-sim-auth} ist vom Gitrepository\footnote{\url{}http://cgit.osmocom.org/cgit/osmo-sim-auth} des Projekts Osmocom zu  beziehen.

	\subsection{Integration mit PPPoE}
        Um den Verbindungsaufbau zwischen \ac{MS} und \ac{AuC} korrekt abzuwickeln muss sowohl der Client
        als auch der Server für \ac{PPPoE} konfiguriert sowie gestartet sein.

		 \subsubsection{Server}
         Hier muss initial der Daemon für den \ac{PPPoE}-Server gestartet sein. Anzugeben ist das gewünschte
         Netz mit zugehöriger Netzwerkschnittstelle. Ebenso muss die IPTables-Regel zur Weiterleitung
         des Internetverkehrs gesetzt sein.

         \subsubsection{Client}
         Hier müssen einmalig über das Tool \textit{pppoe-conf} die Parameter und Authentifizierungsdaten
         für die \ac{PPPoE}-Verbindung eingepflegt werden.

         Das Tool bietet die Möglichkeit selbige Informationen
         zu speichern und automatisch den Verbindungsaufbau mit dem Server aufzunehmen. Bei Neustart
         des Systems oder Verbindungsabbruch (regulär oder durch technische Zwischenfälle) greift dieser
         Mechanismus ebenfalls.

\clearpage
